\documentclass[11pt,a4paper, oneside, oldfontcommands]{memoir}
\usepackage[french]{babel}
\selectlanguage{french}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{microtype}
\usepackage[dvips]{graphicx}
\usepackage{xcolor}
\usepackage{times}
\usepackage[most]{tcolorbox}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[french, onelanguage, noend, ruled, vlined]{algorithm2e}
\usepackage{tikz-qtree}
\usepackage{fontawesome}
\usepackage{tikz}
\usetikzlibrary{automata}

\DeclareMathAlphabet\mathbfcal{OMS}{cmsy}{b}{n}
%usage : \mathcal{} et \mathbfcal{} for bold

\usepackage[
breaklinks=true,colorlinks=true,
%linkcolor=blue,urlcolor=blue,citecolor=blue,% PDF VIEW
linkcolor=black,urlcolor=black,citecolor=black,% PRINT
bookmarks=true,bookmarksopenlevel=2]{hyperref}


\geometry{
  left=25mm,
  right=25mm,
  top=25mm,
  bottom=25mm,
  heightrounded,% better use it
}

%My nice quotation style
\newtcolorbox{siderules}[1][]{blanker, breakable, 
     left=6mm,right=0mm, top=1mm, bottom=1mm,
     borderline west={1pt}{0pt}{black},
     parbox=false, #1}



\OnehalfSpacing
%\linespread{1.3}

%%% CHAPTER'S STYLE
\chapterstyle{bianchi}
%\chapterstyle{ger}
%\chapterstyle{madsen}
%\chapterstyle{ell}
%%% STYLE OF SECTIONS, SUBSECTIONS, AND SUBSUBSECTIONS
\setsecheadstyle{\Large\bfseries\sffamily\raggedright}
\setsubsecheadstyle{\large\bfseries\sffamily\raggedright}
\setsubsubsecheadstyle{\bfseries\sffamily\raggedright}


%%% STYLE OF PAGES NUMBERING
%\pagestyle{companion}\nouppercaseheads 
%\pagestyle{headings}
%\pagestyle{Ruled}
\pagestyle{plain}
\makepagestyle{plain}
\makeevenfoot{plain}{\thepage}{}{}
\makeoddfoot{plain}{}{}{\thepage}
\makeevenhead{plain}{}{}{}
\makeoddhead{plain}{}{}{}

%Define G
\newcommand{\G}{$\mathbfcal{G}$}
%Define V
\newcommand{\V}{$\textbf{\textit{V}}$}
%Define E
\newcommand{\E}{$\textbf{\textit{E}}$}

\maxsecnumdepth{subsection} % chapters, sections, and subsections are numbered
\maxtocdepth{subsection} % chapters, sections, and subsections are in the Table of Contents

% Le bloc qui suit permet de ne pas afficher les numéros devants les sections
\makeatletter
\def\@seccntformat#1{%
  \expandafter\ifx\csname c@#1\endcsname\c@section\else
  \csname the#1\endcsname\quad
  \fi}
\makeatother

%Ceci devrait retirer le 'Chapter N'
\makeatletter
\def\@makechapterhead#1{%
  \vspace*{50\p@}%
  {\parindent \z@ \raggedright \normalfont
    \interlinepenalty\@M
    \Large \bfseries #1\par\nobreak
    \vskip 40\p@
  }}
\def\@makeschapterhead#1{%
  \vspace*{50\p@}%
  {\parindent \z@ \raggedright
    \normalfont
    \interlinepenalty\@M
    \Large \bfseries  #1\par\nobreak
    \vskip 40\p@
  }}
\makeatother

\begin{document}

\thispagestyle{empty}

{%%%
\sffamily
\centering
\Large

~\vspace{\fill}

{\huge 
\textbf{Devoir 3}
}

\vspace{2.5cm}

{
BLAIS REGOUT, Lucien - 18073291\\
SAVOIE, Olivier - 18114274
}

\vspace{3.5cm}

IFT436 - Algoritmes et structures de données\\[1em]

Faculté des Sciences\\
Université de Sherbrooke

\vspace{3.5cm}

Présenté à Pr BLONDIN, Michael

\vspace{\fill}

Jeudi, 10 octobre 2019

%%%
}%%%
\chapter{Question 1}
\section{a)}
  \noindent
  $\V{}$ = Les bassins du manège aquatique (sommets).\\[1em]
  \E{} = Les corridors entre les bassins, potentiellement des glissades(arêtes).\\[1em]
  \G{} = Manège aquatique est dirigé.


\section{b)}
  \G{} ne peut pas être un cycle dû aux contraintes stipulées. Cette contrainte, ci-dessous, en témoigne.\\

  \begin{siderules}
    Il n'y a \textit{pas} de corridor passant d'un bassin vers lui-même.
  \end{siderules}
  
  \noindent
  Il est impossible qu'un cycle soit établi avec un seul bassin considérant qu'il y a aucun corridor qui part d'un dit bassin en arrivant dans ce même bassin.\\[1em]
  
  
  Finalement, cette seconde contrainte, implique que, dû à l'inclinaison, l'un ne peut pas revenir au bassin précédent. Cela implique qu'il y a aucun cycle possible et que de ce fait, le manège aquatique \G{} est acyclique et dirigé.\\
  
  \begin{siderules}
    Puisque les bassins sont situés de plus en plus bas, le long d'une colline, si on peut atteindre un bassin $j$ à partir d'un bassin $i$, alors on ne peut pas atteindre le bassin $i$ à partir du bassin $j$.
  \end{siderules}


\section{c)}
Si le graphe \G{} est considéré non dirigé, il y a plusieurs arrangements d'arêtes qui rendrait \G{} cyclique et pour lesquels $|\E{}| > |\V{}| - 1$. Ainsi, dans la majorité des cas, \G{} n'est pas un arbre, car il ne respecte pas les propriétés essentielles pour en être un. Toutefois, il y a toujours la possibilité qu'aucun cycle, simple ou non, ne s'y retrouve et que le nombre d'arête soit équivalent au nombre de sommet $- 1$. De sorte que les propriétés suivantes soit respectées.\\
  \begin{itemize}
    \item\G{} est $connexe$ et $|\textbf{E}| = |\textbf{V}| - 1$
  \end{itemize} 

\section{d)}



  \begin{gather*}
    min = n-1,\quad \forall n \geq 1\quad
  \end{gather*}
  Dans le cas minimal, les arêtes placées représenterons un graphe \G{} qui sera forcément un arbre, respectant les contraintes, ainsi que l'explication élaborée à la lettre précédente, \textbf{c)}.\\
  \begin{gather*}
    max = \sum_{i=1}^{n} {n-i}=\sum_{i=1}^{n} {n}-\sum_{i=1}^{n} {i}=n^{2}-\frac{n}{2}(n+1)=\frac{n^{2}-n}{2}
  \end{gather*}
  Advennant que chacun des bassins présents se voient attribués un corridor vers chacun des bassins soudjacents, l'équation maximal reflètera la composition du chemin le plus long. 

\section{e)}
  \noindent
  \textbf{Bassin départ :} De toutes les paires de sommets composants les arêtes, le sommet qui se retrouvera uniquement en index $0$ de la paire, à la gauche, qui est donc toujours le sommet de départ, sera donc considéré comme sommet de départ.\\[1em]
  \textbf{Bassin d'arrivée :} Suivre le même résonnement, mais pour le sommet qui se retrouve toujours en index $1$ de la paire et qui est donc toujours le bassin d'arrivée dans toutes les paires, sera donc considéré comme sommet d'arrivée.


\section{f)}
  \IncMargin{1em}
  \begin{algorithm}[H]

    \caption{Calcul de la séquence qui possède un temps maximal passé dans une attraction \G{}}
    \DontPrintSemicolon
    \LinesNumbered
    \SetAlgoLined
    \SetKwProg{Def}{}{:}{}
    \SetKwFunction{Parcours}{parcours}

    \KwIn{Manège \G{} tel que \G{}$ = (\V{},\E{})$ et sommet initial $u$ tel que $u$ appartien à $\V{}$.}
    \KwResult{Une séquence $S$ de bassins de temps maximal dans le manège \G{}.}
    $S \leftarrow [ ]$\;
    $Ttot \leftarrow 0$\;
    $Parent \leftarrow u$\;

    \Def{\Parcours($x$)}{
      $SPrime \leftarrow S$\;
      $Temps \leftarrow Ttot$\;

      \If{$x$ non marquée}{
        $Temps \leftarrow Temps + c[Parent, x]$\;
        \textbf{marquer} $x$\;
        \textbf{ajouter} $x$ à $SPrime$\;
        
        \If{$Temps > Ttot$}{
          $Ttot \leftarrow Temps$\;
          $S \leftarrow SPrime$\;
        }

        \For{$u \in \V{} : x \rightarrow y$}{
          $Parent \leftarrow x$\;
          \Parcours{$y$}
        }
      }
    }
    \Parcours{$u$}\;
    \Return{$S$}
  \end{algorithm}
  \DecMargin{1em}

\section{g)}
  \IncMargin{1em}
  \begin{algorithm}[H]

    \caption{Calcul de la séquence qui possède un temps maximal passé dans une attraction \G{}, donné $5$ remontées}
    \DontPrintSemicolon
    \LinesNumbered
    \SetAlgoLined
    \SetKwProg{Def}{}{:}{}
    \SetKwFunction{Parcours}{parcours}

    \KwIn{Manège \G{} tel que \G{}$ = (\V{},\E{})$, que le sommet initial $u$ tel que $u \in \V{}$, que $v \in \V{}$, ainsi que $v$ est le bassin finale.}
    \KwResult{Une séquence $S$ de bassins, de temps maximal dans le manège \G{}, considérant que l'utilisateur peut remonter au bassin initial un maximum de $5$ fois.}
    $S \leftarrow [\ ]$\;
    $Ttot \leftarrow 0$\;
    $Parent \leftarrow u$\;
    $Ascension \leftarrow 5$\;

    \Def{\Parcours($x$)}{
      $SPrime \leftarrow S$\;
      $Temps \leftarrow Ttot$\;

      \If{$x$ non marquée}{
        $Temps \leftarrow Temps + c[Parent, x]$\;
        \textbf{marquer} $x$\;
        \textbf{ajouter} $x$ à $SPrime$\;
        
        \If{$Temps > Ttot$}{
          $Ttot \leftarrow Temps$\;
          $S \leftarrow SPrime$\;
        }

        \If{prochain voisin de $x = v$}{
          $Ascension \leftarrow Acension - 1$\;
          \textbf{retirer} les marqueurs\;
          $Parent \leftarrow S[0]$\;
          \Parcours{$Parent$}
        }

        \Else{
          \For{$u \in \V{} : x \rightarrow y$}{
            $Parent \leftarrow x$\;
            \Parcours{$y$}
          }
        }
      }
    }
    \Parcours{$u$}\;
    \Return{$S$}
  \end{algorithm}
  \DecMargin{1em}

  \BlankLine

  Ici, il fera exactement comme l'algorithme précédent, à l'exception que lorsqu'il se rendra au plus long parcours précédent le bassin final,
  et se 5 fois. La 5e fois, le sera possiblement différent mais restera cependant couvers par l'algorithme.\\[1em]

\chapter{Question 2}
\section{a)}

\IncMargin{1em}
\begin{algorithm}[H]

  \caption{Tri d'une séquence et calcul des valeurs modales}
  \DontPrintSemicolon
  \LinesNumbered
  \SetAlgoLined
  \SetKwFunction{TMode}{trouverMode}
  \SetKwFunction{Med}{mediane}
  \SetKwProg{Def}{}{:}{}

  \KwIn{Une séquence $S$ non vide d'éléments comparables.}
  \KwResult{Les valeurs modales$m$ trouvées dans la séquence $S$}
  \BlankLine
  $mode \leftarrow [\ ]$\;
  $modeQty \leftarrow 0$\;

  \Def{\TMode($x$)}{

    \If{$|x|=0$}{
      \Return{$mode$}
      }
    \Else{
      $pivot \leftarrow$ \Med{$x$}\;
      $gauche \leftarrow [x \in S: x < pivot]$\;
      $centre \leftarrow [x \in S: x = pivot]$\;
      $droite \leftarrow [x \in S: x > pivot]$\;
      
      \If{$|centre|=modeQty$}{
        \textbf{ajouter} $pivot$ à $mode$\;
      }
      
      \If{$|centre|>modeQty$}{
        $modeQty \leftarrow |centre|$\;
        $mode \leftarrow [pivot]$
      }

      \Else{
        \TMode{$gauche$}\;
        \TMode{$droite$}
      }
    }
  }
  \Return{\TMode{$S$}}  
\end{algorithm}
\DecMargin{1em}


\section{b)}

\resizebox{0.9\textwidth}{!}{
  \begin{tikzpicture}
\Tree
[.{[10, 20, 20, 20, 10, 30, 70, 20, 80, 30, 60, 40, 20, 10, 50, 10, 70, 80]}
  [.{[10, 10, 10, 10]}
    {[ ]}
    {[10, 10, 10, 10]}
    {[ ]}
  ]
  {[20, 20, 20, 20, 20]}
  [.{[30, 70, 80, 30, 60, 40, 50, 70, 80]}
    [.{[30, 30, 40, 50]}
      {[ ]}
      {[30, 30]}
      [.{[40, 50]}
        {[ ]}
        {[40]}
        [.{[50]}
          {[ ]}
          {[50]}
          {[ ]}
        ]
      ]
    ]
    {[60]}
    [.{[70, 80, 70, 80]}
      {[ ]}
      {[70, 70]}
      [.{[80,80]}
        {[ ]}
        {[80, 80]}
        {[ ]}
      ]
    ]
  ]
]
  \end{tikzpicture}
}

\chapter{Question 3}
\section{a)}

\noindent
\begin{siderules}
  \textbf{Donnez un algorithme qui détermine si un graphe non dirigé est un arbre.}
\end{siderules}
\BlankLine

\IncMargin{1em}
\begin{algorithm}[H]

  \caption{Détermination de la propriété d'arbre d'un graphe.}
  \DontPrintSemicolon
  \LinesNumbered
  \SetAlgoLined
  \SetKwFunction{Vis}{visiter}
  \SetKwProg{Def}{}{:}{}

  \KwIn{Un graph \G{} tel que \G{}$=(\V{},\E{})$ est non dirié et un sommet $u \in \V{}$}
  \KwResult{Si le graphe est un arbre, ou non.}
  \BlankLine
  $Visites \leftarrow 0$\;

  \Def{\Vis{$x$}}{

    \If{$x$ est marqué}{
      \Return{$Non\_Arbre$}
    }
    \textbf{marquer} $x$\;
    $Visites \leftarrow Visites + 1$\;
    \ForAll{voisins de $x \in \V{} : x \rightarrow y$}{
      \Vis{$y$}\;
    }
  }
  \Vis{$u$}\;
  \If{$Visites \neq ||$}{
    \Return{$Non\_Arbre$}
  }
  \Else{
    \Return{$Est\_Arbre$}
  }
\end{algorithm}
\DecMargin{1em}

Cet algorithme parcours le graph au complet. Si un sommet est visité plus d'une fois, c'est cyclique. Cela est uniquement véridicte lorsqu'on empêche de visiter le noeud précédents en visitant tous les voisins immédiats.\\

Deplus, tous les sommets peuvent être visiter moins de deux fois et tout de même il pourrait y manquer certains sommets, d'ou la vérification si le nombre de visites est bien égale a la somme des sommets dans le graphes!

\section{b)}

\noindent
\begin{siderules}
  \textbf{Démontrez que le graphe complet \G{}$_n$ possède au moins $2^n$ arbres couvrants, $\forall n \in \mathbb{N} > 3$ .}
\end{siderules}

Une façon compréhensive de le démontrer est de représenter chacun des sommets comme une valeurs binaire.
Lors d'un compte binaire (\textit{ie}: l'évaluation de $101_2$ qui donne $5$) on réalise qu'il y a jusqu'a $8$ manières différentes d'agencer $3$ valeurs, $3$ sommets.
Maintenant, si nous retrouvons $4$ somets, il y a alors $4$ valeurs qui peuvent être agencer jusqu'a $16$ façons uniques. 
Ceci, qui suit cette même relation binaire, gradue en fonction du nombre d'objet à relier par le l'arbre couvrant $\mathbfcal{H}$ du graphe complet, acyclique et non dirigé \G{}.\\

Ainsi, avec $n$ sommets, il y a $2^n$ manières de les agencer afin de couvrir tout les sommets et d'accomplir la tâche requise!



\section{c)}

\noindent
\begin{siderules}
  \textbf{Donnez un exemple de points où un arbre couvrant minimal entre ces points est plus long qu'un arbre couvrant minimal avec un nouveau point ajouté (une halte).}
\end{siderules}

\begin{figure}[!h]
  \centering
%%%% BLEU COMME DANS SON DOCUMENT
\begin{tikzpicture}[node distance=2cm, baseline=0]
  %$ Sommets
  \tikzset{every state/.style={minimum size=10pt, inner sep=0pt, white}}

  \node[state]              (0) {};
  \node[state] [right of=0] (1) {};
  \node[state] [below of=0] (2) {};
  \node[state] [below of=1] (3) {};
  \node[text width=4cm, anchor=west, right, align=center] at (4, -1){$3 * 1 = 3 u$};

  %% Arêtes
  \path[-, gray]
  (0) edge node {} (1)
  (0) edge node {} (2)
  (0) edge node {} (3)
  (1) edge node {} (2)
  (1) edge node {} (3)
  (2) edge node {} (3)
  ;

  %% Arbre couvrant
  \path[-, line width=4pt, cyan]
  (0) edge node {} (1)
  (0) edge node {} (2)
  (1) edge node {} (3)
  ;

  %% Gîtes
  \tikzset{every node/.style={font=\LARGE}}

  \node[yshift=1.2pt] at (0) {\faHome};
  \node[yshift=1.2pt] at (1) {\faHome};
  \node[yshift=  0pt] at (2) {\faHome};
  \node[yshift=  0pt] at (3) {\faHome};
\end{tikzpicture}
\end{figure}

Dans cette image, on retrouve un arbre couvrant minimal qui couvre $4$ sommets d'un graph \G{} à $4$ sommets.
Assumant qu'il y a $1$ unité ($u$) de distance entre les coins, du carré formé, adjacants, le graph aurait une longueur suivant l'équation ci-dessus.

\BlankLine

\begin{figure}[!h]
  \centering
%%%% ROUUUUUGE
\begin{tikzpicture}[node distance=2cm]
  %$ Sommets
  \tikzset{every state/.style={minimum size=10pt, inner sep=0pt, white}}

  \node[state]              (0) {};
  \node[state] [right of=0] (1) {};
  \node[state] [below of=0] (2) {};
  \node[state] [below of=1] (3) {};
  \node[text width=4cm, anchor=west, right, align=center] at (4, -1){$4(\frac{1}{3})(1^2 + 1^2)=2^{1/2}=2.8284\dots u$};

  %% Arêtes
  \path[-, gray]
  (0) edge node {} (1)
  (0) edge node {} (2)
  (0) edge node {} (3)
  (1) edge node {} (2)
  (1) edge node {} (3)
  (2) edge node {} (3)
  ;

  %% Arbre couvrant
  \path[-, line width=4pt, red]
  (0) edge node {} (3)
  (1) edge node {} (2)
  ;

  %% Gîtes
  \tikzset{every node/.style={font=\LARGE}}

  \node[yshift=1.2pt] at (0) {\faHome};
  \node[yshift=1.2pt] at (1) {\faHome};
  \node[yshift=  0pt] at (2) {\faHome};
  \node[yshift=  0pt] at (3) {\faHome};
\end{tikzpicture}
\end{figure}

Maintenant, ces gites sont équidistant de cette halte, sont à la même position que le graphe précédent et la distance totale de chacun des gites à la halte va comme suit.

\end{document}